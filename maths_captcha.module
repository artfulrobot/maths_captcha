<?php
/**
 * @file
 * Maths Captcha module.
 *
 * Protects specified forms from spam entry by requiring user to submit answer
 * to simple maths question
 *
 * @Copyright Copyright 2014 Rich Lott
 *
 * LICENSE
 *
 * This file is part of Maths Captcha.
 *
 * Maths Captcha is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Maths Captcha is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Maths Captcha. If not, see <http://www.gnu.org/licenses/>
 */

/**
 * Config form menu item.
 *
 * Implements hook_menu().
 */
function maths_captcha_menu() {
  $items['admin/config/content/maths_captcha'] = array(
    'title' => 'Maths Capcha configuration',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('maths_captcha_config'),
    'access arguments' => array('administer maths captcha'),
  );
  return $items;
}

/**
 * Config form.
 */
function maths_captcha_config() {
  $form = array(
    'maths_captcha_protect' => array(
      '#title' => 'Form Ids to protect (you can use * for wildcard)',
      '#description' => t('Enter form ids one per line'),
      '#type' => 'textarea',
      '#default_value' => variable_get('maths_captcha_protect', ''),
    ),
    'maths_captcha_error_log' => array(
      '#title' => 'Log to error_log?',
      '#description' => t('This is useful if you want to use this in conjunction with external server tools like fail2ban.'),
      '#type' => 'checkbox',
      '#default_value' => variable_get('maths_captcha_error_log', FALSE),
    ),
  );
  return system_settings_form($form);
}

/**
 * Implements hook_permission().
 */
function maths_captcha_permission() {
  return array(
    'administer maths captcha' => array(
      'title' => t('Administer Maths Captcha'),
      'description' => t('Specify which forms to protect'),
    ),
    'skip maths captcha' => array(
      'title' => t('Skip Maths Captcha'),
      'description' => t('Users with this role will never be required to complete the captcha.'),
    ),
  );
}


/**
 * Create a new hash, valid for 15 minutes.
 */
function maths_captcha_hash_new($rand1 = NULL, $rand2 = NULL) {
  $valid_to = strtotime('now + 15 minutes');
  if ($rand1 === NULL) {
    $rand1 = (int) rand(0, 9);
  }
  if ($rand2 === NULL) {
    $rand2 = (int) rand(0, 9);
  }
  return maths_captcha_hash_create($rand1, $rand2, $valid_to);
}
/**
 * Create a hash for the given parameters.
 *
 * Hash format is:
 *
 * - four bytes: the two numbers, base64 encoded XOR-ed
 * - 32 bytes: md5 hash, inc. salt, both numbers and the
 *     valid to timestamp
 * - colon
 * - string representation of valid to timestamp
 */
function maths_captcha_hash_create($rand1, $rand2, $valid_to) {
  $hash = md5("This hash will work for $rand1 and $rand2 until $valid_to for $_SERVER[REMOTE_ADDR]") . ":$valid_to";

  // Encrypt question - will generate 4 bytes.
  $enc = base64_encode("$rand1$rand2" ^ substr($hash, 0, 2));
  // Prepend to hash.
  $hash = $enc . $hash;

  return $hash;
}
/**
 * Parse, validate and check hash and (optionally) answer.
 *
 * Returns array of unpacked values:
 *
 * - rand1, rand2
 * - validTo: timestamp
 * - valid: boolean. was the hash valid (inc. timeout)
 * - correct: if an answer was given and the hash was valid, this is evaluated
 *            to boolean
 * - error: human friendly error. Real humans should only see the timeout and
 *          incorrect answer texts.
 */
function maths_captcha_hash_parse($hash, $answer = NULL) {
  $result = array(
    'rand1' => NULL,
    'rand2' => NULL,
    'validTo' => NULL,
    'valid' => NULL,
    'correct' => NULL,
    'error' => FALSE,
    'hash' => $hash,
    'answer' => $answer,
  );

  if (!preg_match('/^(....)(.{32}):(\d+)$/', $hash, $matches)) {
    // format of hash is wrong
    $result['error'] = 'Tampered1';
    $result['hash'] = '{invalid hash removed}';
    return $result;
  }
  $matches[1] = base64_decode($matches[1]) ^ substr($matches[2], 0, 2);
  if (!preg_match('/^[0-9][0-9]$/', $matches[1])) {
    // decrypted question numbers are not numbers!
    $result['error'] = 'Tampered2';
    return $result;
  }
  $result['rand1'] = $matches[1][0];
  $result['rand2'] = $matches[1][1];
  $result['validTo'] = $matches[3];
  $hash_expected = maths_captcha_hash_create($result['rand1'], $result['rand2'], $result['validTo']);
  $result['valid'] = $hash == $hash_expected;
  if (! $result['valid']) {
    // This means that the hash is wrong. Typically this means that it was issued to a different IP address.
    $result['error'] = 'Tampered3';
    return $result;
  }
  // Further date check.
  if ($result['validTo'] < time()) {
    $result['valid'] = FALSE;
    $result['error'] = t('The human-checking maths test timed out, please check and re-submit.');
    return $result;
  }
  // Final answer check.
  if ($answer !== NULL) {
    if (!preg_match('/^\d\d?$/', $answer)) {
      // Many spambots submit random text.
      // A human should always submit simple number.
      $result['correct'] = FALSE;
      $result['valid'] = FALSE;
      $result['error'] = t('Invalid answer to maths test.');
      // Todo: implement time-based IP lock-out.
    }
    else {
      $result['correct'] = ($result['rand1'] + $result['rand2']) == $answer;
      if (!$result['correct']) {
        // Force a new test to be created, so can't answer by looping.
        $result['valid'] = FALSE;
        $result['error'] = t('Wrong answer to maths test.');
      }
    }
  }
  return $result;
}

/**
 * Renew an existing hash.
 *
 * This is not currently in use.
 */
function maths_captcha_hash_renew($hash) {
  $parsed = maths_captcha_hash_parse($hash);
  return maths_captcha_hash_new($parsed['rand1'], $parsed['rand2']);
}

/**
 * Protect a form.
 *
 * Implements hook_form_alter().
 *
 * Adds the maths_q and maths_a elements to protected forms.
 * This can also be programatically disabled by setting
 *       $form['#maths_captcha_disable'] = TRUE;
 *
 * The element is added to the first of these preferred places:
 *
 * 1. inside the (root) maths_captcha_container element
 * 2. immediately before the first submit element
 * 3. at the end
 */
function maths_captcha_form_alter(&$form, &$form_state, $form_id) {
  // Check if this is one we should care about.
  if (!maths_captcha_should_protect($form_id)
    || !empty($form['#maths_captcha_disable'])
    || user_access('skip maths captcha') ) {
    return;
  }

  // We have to use 'input' here because 'values' does not
  // exist yet.
  if (!empty($form_state['input']['maths_q'])) {
    $hash = $form_state['input']['maths_q'];
    $parsed = maths_captcha_hash_parse($hash, $form_state['input']['maths_a']);
    if (!$parsed['valid']) {
      $hash = FALSE;
    }
    // Allow the next line to debug.
    if (variable_get('maths_captcha_error_log',FALSE)) {
      $answer = substr($parsed['answer'], 0, 20);
      // remove anything non-ascii safe for log file (stop at 7d means we exclude our field sep | at the cost of excluding ~ too).
      if (!preg_match('/^[\x20-\x7d]*$/',$answer)) {
        $answer = '(non-ASCII text removed)';
      }
      $log_line = 'maths_captcha|'
        . ($parsed['valid'] ? 'Valid' . ($parsed['correct'] ? ':pass' : ':fail' ): 'INVALID' )
        . "|$parsed[error]|$parsed[hash]|$parsed[rand1] + $parsed[rand2] = $answer|";
      error_log($log_line);
      if (substr($parsed['error'],0,8) == 'Tampered') {
        // Issue a fake 404 - hopefully this will make spammers remove the page from their hitlist?
        header('HTTP/1.0 404 Gone');
        exit();
      }
    }
  }
  if (empty($hash)) {
    $hash = maths_captcha_hash_new();
    $parsed = maths_captcha_hash_parse($hash);
  }

  // Create form elements.
  $captcha_form = array(
    'maths_q' => array(
      '#type' => 'hidden',
      '#value' => $hash,
    ),
    'maths_a' => array(
      '#type' => 'textfield',
      '#size' => 3,
      '#title' => t('Human test (to stop spam): what is ')
      . maths_captcha_obfuscate($parsed['rand1'])
      . t(' plus ')
      . maths_captcha_obfuscate($parsed['rand2'])
      . t(' (answer in numbers not words)'),
      '#default_value' => '',
    ));

  // Look for maths_captcha_container as 1st preference.
  if (array_key_exists('maths_captcha_container', $form)) {
    $form['maths_captcha_container'] += $captcha_form;

  }
  else {
    // We need to insert before the submit...
    $i = 0;
    foreach ($form as $details) {
      if (is_array($details)
        && array_key_exists('#type', $details)
        && $details['#type'] == 'submit') {
        break;
      }
      $i++;
    }
    $form = array_merge(
      array_slice($form, 0, $i),
      $captcha_form,
      array_slice($form, $i));
  }

  $form['#validate'][] = 'maths_captcha_form_validate';
}

/**
 * Validation for protected forms.
 */
function maths_captcha_form_validate($form, &$form_state) {
  /*
   * Important that we compare the value passed (input), not the value from
   * the form, which is new each time.  this means that if somehow the
   * maths_q field got corrupted, it would fail but the human would get a new
   * maths test, and then next time their answer is compared against what was
   * sent.
   */
  $hash = $form_state['input']['maths_q'];
  $parsed = maths_captcha_hash_parse($hash, $form_state['values']['maths_a']);
  if (!$parsed['correct']) {
    form_set_error('maths_a', $parsed['error']);
  }
}

/**
 * Determine whether this form should be protected.
 */
function maths_captcha_should_protect($form_id) {
  $protect = preg_split('/[\r\n]+/', variable_get('maths_captcha_protect', ''));
  foreach ($protect as $pattern) {
    if ($pattern && fnmatch($pattern, $form_id)) {
      return TRUE;
    }
  }
  return FALSE;
}
/**
 * Obfuscation function for the numbers in the question.
 */
function maths_captcha_obfuscate($number) {
  $map = &drupal_static(__FUNCTION__);
  if (!isset($map)) {
    $map = array(
      0 => t('zero'),
      1 => t('one'),
      2 => t('two'),
      3 => t('three'),
      4 => t('four'),
      5 => t('five'),
      6 => t('six'),
      7 => t('seven'),
      8 => t('eight'),
      9 => t('nine'),
    );
  }

  // Convert to words 80% of the time.
  if (rand(0,10)<80) {
    $number = $map[$number];
  }

  $length = mb_strlen($number);
  $output = '';
  for ($i=0;$i<$length;$i++) {
    $char = mb_substr($number, $i, 1);
    if (strlen($char) == 1 && rand(0,100)<50) {
      // 50% of the time, for single byte characters,
      // conver to a numerical entity.
      $char = "&#" . ord($char) . ";";
    }
    $mix = rand(1,3);
    switch ($mix) {
    case 1:
      // A third of the time add an empty span containing another random number
      $char .= "<span title=" . rand(0,9) . "></span>";
      break;
    case 2:
      // or add a misleading comment
      $char .= "<!-- " . rand(0,9) . "-->";
      break;
    case 3:
      // or wrap it in a span
      $char = "<span data-number='" . rand(0,9) . "'>$char</span>";
    }
    $output .= $char;
  }

  return $output;
}
